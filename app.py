from sqlmodel import Field, Session, SQLModel, create_engine


# table=True tells SQLModel that this is a table model
# without it, it would only be a data model
class Hero(SQLModel, table=True):
    # the id is aways required in the database and it will be
    # generated by the database (not by our code), so that's
    # why it's hinted as optional (int | None)
    id: int = Field(default=None, primary_key=True)
    name: str
    secret_name: str
    # when hinting a field as optional, we tell SQLModel that
    # said field is not required when validating the data and that
    # it has a default value of none (null for most databases)
    age: int | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

# the "engine" is the object that will allow us to interact with the database
# the "echo=True" argument tells SQLModel to print the SQL statements that it's
# generating for us, we usually don't want this in production
# for more info https://docs.sqlalchemy.org/en/20/tutorial/engine.html
engine = create_engine(sqlite_url, echo=True)


# Creating the engine doesn't create the database.db file
# But once we run SQLModel.metadata.create_all(engine)
# it creates the database.db file and the tables that we've defined
# https://sqlmodel.tiangolo.com/tutorial/create-db-and-table/#sqlmodel-metadata
# the method bellow should be called after the code that create new model classes
# inheriting from SQLModel, otherwise the new tables won't be created
# an great alternative is importing SQLModel ant the models in a db.py file
# https://sqlmodel.tiangolo.com/tutorial/create-db-and-table/#sqlmodel-metadata-order-matters
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def create_heroes():
    hero1 = Hero(name="Deadpond", secret_name="Dive Wilson")
    hero2 = Hero(name="Rusty-Man", secret_name="Tommy Sharp", age=48)
    hero3 = Hero(name="Spider-boy", secret_name="Pedro Parqueador")

    # In contrast to the engine that is one for the whole application,
    # we create a new session for each group of operations with the
    # database that belong together. In contrast to the engine that is one
    # for the whole application, we create a new session for each group of
    # operations with the database that belong together.
    # session = Session(engine)  -> The session will create a new transaction
    # and execute all the SQL code in that transaction.

    #  session.add(hero1)
    #  session.add(hero2)
    #  session.add(hero3)

    #   "session.commit()" -> commits the transactions to the database
    #   "session.close()" -> if an error happen betweem the add and the commit,
    #   the session will not be closed and the database will be left in an
    #   inconsistent state. To avoid this, we can use the with keyword with the commit fn

    # this is the same as creating and closing the session manually, the with block
    # will automatically create and close the session for us, even if an error happens
    with Session(engine) as session:
        session.add(hero1)
        session.add(hero2)
        session.add(hero3)

        session.commit()


def main():
    create_db_and_tables()
    create_heroes()


# the purpose of this if statement is to have some code executed when this file
# is called with "python filename.py" but not when it's called when another file
# imports it
if __name__ == "__main__":
    main()
